// MasterClient
// auto-generated source code: main.go
// by arion (https://github.com/straightdave/arion)
package main

import (
    "bytes"
    "flag"
    "fmt"
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "os"
    "regexp"
    "strings"
    "text/template"

    "github.com/golang/protobuf/jsonpb"
    "golang.org/x/net/context"
    "google.golang.org/grpc"

    gozip "github.com/straightdave/gozip/lib"
    "github.com/straightdave/lesphina"
)

var (
    _list       = flag.Bool("list", false, "list all endpoints")
    _serve      = flag.String("serve", "", "if specified, serve stub as http service")
    _host       = flag.String("host", ":8087", "host of target service")
    _call       = flag.String("call", "", "method name to call")
    _rawRequest = flag.String("req", "", "raw request json")

    _regexMethodPath = regexp.MustCompile(`grpc\.Invoke.+?"(.+?)"`)
)

var (
    _les  *lesphina.Lesphina
    _conn *grpc.ClientConn
)

const (
    MimeHtml = "text/html"
    MimeCss  = "text/css"
    MimeJs   = "text/javascript"
    MimeJson = "application/json"
)

func init() {
    flag.Parse()

    _les = lesphina.Restore(_lesDump)

    var err error
    if _conn, err = grpc.Dial(*_host, grpc.WithInsecure()); err != nil {
        log.Fatalf("[init] failed to dial: %v\n", err)
    }
}

func main() {
    defer func() {
        if r := recover(); r != nil {
            log.Fatalf("panic in main: %v\n", r.(error))
        }
    }()

    if len(os.Args) == 1 {
        flag.PrintDefaults()
        return
    }

    if *_serve != "" {
        realHtml := genHtml(gozip.DecompressString(html2))
        serveStaticContent("/", MimeHtml, realHtml)
        serveStaticContent("/m.css", MimeCss, gozip.DecompressString(css))
        serveStaticContent("/m.js", MimeJs, gozip.DecompressString(js))

        http.HandleFunc("/type", handleGetType)
        http.HandleFunc("/meta", handleGetMeta)
        http.HandleFunc("/call", handleCallEndpoint)

        srv := &http.Server{Addr: *_serve}
        log.Fatal(srv.ListenAndServe())
    }

    if *_list {
        q := _les.Query().ByKind(lesphina.KindInterface).ByName("~Client").All()
        for _, intr := range q {
            svc, ok := intr.(*lesphina.Interface)
            if !ok {
                log.Println("the obj found is not interface, weird")
                continue
            }

            fmt.Println(svc.GetName())
            for _, m := range svc.Methods {
                fmt.Printf("> %s\n", m.GetName())
            }
            fmt.Println()
        }
        return
    }

    if *_call != "" {
        log.Println(callEndpoint(*_call, *_rawRequest))
        return
    }
}

type HtmlData struct {
    ArionVersion string
    Services     []ServiceData
}

type ServiceData struct {
    Name      string
    Endpoints []EndpointData
}

type EndpointData struct {
    Name         string
    ReqElements  []ElementData
    RespElements []ElementData
}

type ElementData struct {
    Name string
    Type string
}

func genHtmlData() HtmlData {
    res := HtmlData{
        ArionVersion: "0.0.1",
    }

    rawInterfaces := _les.Query().ByKind(lesphina.KindInterface).ByName("~Client").All()
    for _, intf := range rawInterfaces {
        svc, ok := intf.(*lesphina.Interface)
        if !ok {
            log.Println("the obj found is not interface, weird")
            continue
        }

        svcData := ServiceData{
            Name: svc.GetName(),
        }

        // each endpoint
        for _, m := range svc.Methods {
            endData := EndpointData{
                Name: m.GetName(),
            }

            // get endpoint's req struct fields
            reqstru := _les.Query().ByKind(lesphina.KindStruct).ByName(m.GetName() + "Request").First()
            if reqstru != nil {
                if st, ok := reqstru.(*lesphina.Struct); ok {
                    for _, f := range st.Fields {
                        endData.ReqElements = append(endData.ReqElements, ElementData{
                            Name: f.Name,
                            Type: f.RawType,
                        })
                    }
                }
            }

            // get endpoint's resp struct fields
            respstru := _les.Query().ByKind(lesphina.KindStruct).ByName(m.GetName() + "Response").First()
            if respstru != nil {
                if st, ok := respstru.(*lesphina.Struct); ok {
                    for _, f := range st.Fields {
                        endData.RespElements = append(endData.RespElements, ElementData{
                            Name: f.Name,
                            Type: f.RawType,
                        })
                    }
                }
            }

            svcData.Endpoints = append(svcData.Endpoints, endData)
        }
        res.Services = append(res.Services, svcData)
    }

    return res
}

func genHtml(raw string) string {
    t, err := template.New("html2").Parse(raw)
    if err != nil {
        panic(err)
    }

    var buf bytes.Buffer
    if err := t.Execute(&buf, genHtmlData()); err != nil {
        panic(err)
    }
    return buf.String()
}

func serveStaticContent(path, mime, content string) {
    http.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
        defer recoverHandling(w)
        w.Header().Add("Content-Type", mime)
        io.WriteString(w, content)
    })
}

func handleGetType(w http.ResponseWriter, r *http.Request) {
    defer recoverHandling(w)

    typeName := strings.TrimSpace(r.URL.Query().Get("n"))
    if typeName == "" {
        http.Error(w, "lacking of query keyword (n)", http.StatusBadRequest)
        return
    }

    t := _les.Query().ByName(typeName).First()
    switch t.GetKind() {
    case lesphina.KindFunction:
        tt := t.(*lesphina.Function)
        io.WriteString(w, tt.Json())
    case lesphina.KindStruct:
        tt := t.(*lesphina.Struct)
        io.WriteString(w, tt.Json())
    case lesphina.KindElement:
        tt := t.(*lesphina.Element)
        io.WriteString(w, tt.Json())
    default:
        io.WriteString(w, `{"err":"unknown or unsupport type"}`)
    }
}

func handleGetMeta(w http.ResponseWriter, r *http.Request) {
    defer recoverHandling(w)
    io.WriteString(w, _les.Meta.Json())
}

func handleCallEndpoint(w http.ResponseWriter, r *http.Request) {
    defer recoverHandling(w)

    if r.Method != "POST" {
        http.Error(w, "only support POST", http.StatusBadRequest)
        return
    }

    endpointName := strings.TrimSpace(r.URL.Query().Get("e"))
    if endpointName == "" {
        http.Error(w, "lacking of query keyword (e)", http.StatusBadRequest)
        return
    }

    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "can't read body", http.StatusBadRequest)
        return
    }

    io.WriteString(w, callEndpoint(endpointName, string(body)))
}

func callEndpoint(endpointName, rawRequest string) (res string) {
    defer func() {
        if r := recover(); r != nil {
            res = fmt.Sprintf("Panic in CallEndpoint: %v", r.(error))
        }
    }()

    var svcName, endName string
    i := strings.LastIndex(endpointName, "#")
    if i > 0 {
        svcName = endpointName[:i]
        endName = endpointName[i+1:]
    } else {
        endName = endpointName
    }

    method, err := getMethodPath(svcName, endName)
    if err != nil {
        return "Parsing method path failed: " + err.Error()
    }

    req := getVarByTypeName(endName + "Request")
    if req == nil {
        return "No such type: " + endName + "Request"
    }

    reply := getVarByTypeName(endName + "Response")
    if reply == nil {
        return "No such type: " + endName + "Response"
    }

    if err := jsonpb.UnmarshalString(rawRequest, req); err != nil {
        return "Cannot unmarshal raw request value: " + err.Error()
    }

    ctx := context.Background()
    var opts []grpc.CallOption
    if err := _conn.Invoke(ctx, method, req, reply, opts...); err != nil {
        return "Invoking failed: " + err.Error()
    }
    return reply.String()
}

func getMethodPath(svcName, endName string) (res string, err error) {
    qCandidates := _les.Query().ByKind(lesphina.KindFunction).ByName(endName).All()
    if len(qCandidates) < 1 {
        return "", fmt.Errorf("No function found by name: %s", endName)
    }

    var target *lesphina.Function
    for _, c := range qCandidates {
        if f, ok := c.(*lesphina.Function); ok {
            if len(f.Recv) < 1 {
                continue
            }

            // recv type should end with string 'Client'
            if !strings.HasSuffix(f.Recv[0].BaseType, "Client") {
                continue
            }

            if svcName != "" {
                // if svcName is given, return the first candidate under this svc
                if strings.ToLower(f.Recv[0].BaseType) == strings.ToLower(svcName) {
                    target = f
                    break
                }
            } else {
                // if svcName is not given, return the first candidate
                target = f
                break
            }
        }
    }

    if target == nil {
        return "", fmt.Errorf("Endpoint Not Found (svcName: %s, endName: %s)", svcName, endName)
    }

    rawBody := target.RawBody
    if rawBody == "" {
        return "", fmt.Errorf("Blank endpoint")
    }

    m := _regexMethodPath.FindAllStringSubmatch(rawBody, 1)
    if len(m) > 0 && len(m[0]) > 1 {
        return m[0][1], nil
    }
    return "", fmt.Errorf("No match in rawBody")
}

func recoverHandling(w http.ResponseWriter) {
    if r := recover(); r != nil {
        io.WriteString(w, r.(error).Error())
    }
}
