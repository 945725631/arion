// MasterClient
// auto-generated source code: main.go
// by arion (https://github.com/straightdave/arion)
package main

import (
    "bytes"
    "flag"
    "fmt"
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "net/url"
    "os"
    "regexp"
    "strings"
    "text/template"

    "github.com/fatih/color"
    "github.com/golang/protobuf/jsonpb"
    "golang.org/x/net/context"
    "google.golang.org/grpc"

    gozip "github.com/straightdave/gozip/lib"
    "github.com/straightdave/lesphina"
)

var (
    // global lesphina instance
    _les *lesphina.Lesphina
    // flags
    _serve      = flag.Bool("serve", false, "use PostGal in browser mode")
    _list       = flag.Bool("list", false, "list all endpoints")
    _arionHost  = flag.String("at", ":9999", "address to host PostGal in browser mode")
    _host       = flag.String("host", ":8087", "host of target service")
    _call       = flag.String("call", "", "method name to call")
    _rawRequest = flag.String("req", "{}", "raw request json")
    // regex to find endpoint call path
    _regexMethodPath = regexp.MustCompile(`grpc\.Invoke.+?"(.+?)"`)
)

const (
    Ver      = "0.0.1"
    MimeHtml = "text/html"
    MimeCss  = "text/css"
    MimeJs   = "text/javascript"
    MimeJson = "application/json"
    // default arion serving port (only used in browser mode)
    _defaultPort = "9999"
)

func init() {
    flag.Parse()
    _les = lesphina.Restore(_lesDump)
}

func main() {
    defer func() {
        if r := recover(); r != nil {
            log.Fatalf("Recovered panic in main: %v\n", r.(error))
        }
    }()
    red := color.New(color.FgRed).SprintfFunc()

    if len(os.Args) == 1 {
        flag.PrintDefaults()
        return
    }

    // if _serve is provided, browser mode
    if *_serve {
        realHtml := genHtml(gozip.DecompressString(html2))
        serveStaticContent("/", MimeHtml, realHtml)
        serveStaticContent("/m.css", MimeCss, gozip.DecompressString(css))
        serveStaticContent("/m.js", MimeJs, gozip.DecompressString(js))
        http.HandleFunc("/type", handleGetType)
        http.HandleFunc("/meta", handleGetMeta)
        http.HandleFunc("/call", handleCallEndpoint)
        srv := &http.Server{Addr: *_arionHost}
        log.Fatal(srv.ListenAndServe())
        // blocking until ctrl-C is hit, and then app exits
    }

    if *_list {
        q := _les.Query().ByKind(lesphina.KindInterface).ByName("~Client").All()
        for _, intr := range q {
            svc, ok := intr.(*lesphina.Interface)
            if !ok {
                log.Println("the obj found is not interface, weird")
                continue
            }
            fmt.Println(svc.GetName())
            for _, m := range svc.Methods {
                fmt.Printf("> %s\n", m.GetName())
            }
            fmt.Println()
        }
        return
    }

    if *_call != "" {
        resp, err := callEndpoint(*_call, *_host, *_rawRequest)
        if err != nil {
            fmt.Println(red("ERROR ") + err.Error())
            return
        }
        fmt.Println(resp)
    }
}

func getPort(rawAddress string) string {
    splits := strings.Split(rawAddress, ":")
    if len(splits) >= 2 {
        last := splits[len(splits)-1]
        last = strings.TrimSpace(last)
        if last != "" {
            return last
        }
    }
    return _defaultPort
}

type HtmlData struct {
    ArionVersion string
    ArionPort    string
    Services     []ServiceData
}

type ServiceData struct {
    Name      string
    Endpoints []EndpointData
}

type EndpointData struct {
    Name         string
    ReqElements  []ElementData
    RespElements []ElementData
}

type ElementData struct {
    Name          string
    Type          string
    JsonFieldName string
}

func genHtmlData() HtmlData {
    res := HtmlData{
        ArionVersion: Ver,
        ArionPort:    getPort(*_arionHost),
    }

    rawInterfaces := _les.Query().ByKind(lesphina.KindInterface).ByName("~Client").All()
    for _, intf := range rawInterfaces {
        svc, ok := intf.(*lesphina.Interface)
        if !ok {
            log.Println("the obj found is not interface, weird")
            continue
        }

        svcData := ServiceData{
            Name: svc.GetName(),
        }

        // each endpoint
        for _, m := range svc.Methods {
            endData := EndpointData{
                Name: m.GetName(),
            }

            // get endpoint's req struct fields
            reqstru := _les.Query().ByKind(lesphina.KindStruct).ByName(m.GetName() + "Request").First()
            if reqstru != nil {
                if st, ok := reqstru.(*lesphina.Struct); ok {
                    for _, f := range st.Fields {
                        endData.ReqElements = append(endData.ReqElements, ElementData{
                            Name:          f.Name,
                            Type:          f.RawType,
                            JsonFieldName: f.JsonFieldName(),
                        })
                    }
                }
            }

            // get endpoint's resp struct fields
            respstru := _les.Query().ByKind(lesphina.KindStruct).ByName(m.GetName() + "Response").First()
            if respstru != nil {
                if st, ok := respstru.(*lesphina.Struct); ok {
                    for _, f := range st.Fields {
                        endData.RespElements = append(endData.RespElements, ElementData{
                            Name:          f.Name,
                            Type:          f.RawType,
                            JsonFieldName: f.JsonFieldName(),
                        })
                    }
                }
            }

            svcData.Endpoints = append(svcData.Endpoints, endData)
        }
        res.Services = append(res.Services, svcData)
    }
    return res
}

func genHtml(raw string) string {
    t, err := template.New("html2").Parse(raw)
    if err != nil {
        panic(err)
    }

    var buf bytes.Buffer
    if err := t.Execute(&buf, genHtmlData()); err != nil {
        panic(err)
    }
    return buf.String()
}

func serveStaticContent(path, mime, content string) {
    http.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
        defer recoverHandling(w)
        w.Header().Add("Content-Type", mime)
        io.WriteString(w, content)
    })
}

func handleGetType(w http.ResponseWriter, r *http.Request) {
    defer recoverHandling(w)

    typeName := strings.TrimSpace(r.URL.Query().Get("n"))
    if typeName == "" {
        http.Error(w, "lacking of query keyword (n)", http.StatusBadRequest)
        return
    }

    t := _les.Query().ByName(typeName).First()
    switch t.GetKind() {
    case lesphina.KindFunction:
        tt := t.(*lesphina.Function)
        io.WriteString(w, tt.Json())
    case lesphina.KindStruct:
        tt := t.(*lesphina.Struct)
        io.WriteString(w, tt.Json())
    case lesphina.KindElement:
        tt := t.(*lesphina.Element)
        io.WriteString(w, tt.Json())
    default:
        io.WriteString(w, `{"err":"unknown or unsupport type"}`)
    }
}

func handleGetMeta(w http.ResponseWriter, r *http.Request) {
    defer recoverHandling(w)
    io.WriteString(w, _les.Meta.Json())
}

func handleCallEndpoint(w http.ResponseWriter, r *http.Request) {
    defer recoverHandling(w)

    if r.Method != "POST" {
        http.Error(w, "only support POST", http.StatusBadRequest)
        return
    }

    v, err := url.ParseQuery(r.URL.RawQuery)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    endpointName := v.Get("e")
    if endpointName == "" {
        http.Error(w, "lacking of query keyword (e)", http.StatusBadRequest)
        return
    }

    hostAddr := v.Get("h")
    if hostAddr == "" {
        http.Error(w, "lacking of query keyword (e)", http.StatusBadRequest)
        return
    }

    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "can't read body", http.StatusBadRequest)
        return
    }

    res, err := callEndpoint(endpointName, hostAddr, string(body))
    if err != nil {
        io.WriteString(w, err.Error())
        return
    }
    io.WriteString(w, res)
}

func callEndpoint(endpointName, hostAddr, rawRequest string) (res string, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = r.(error)
        }
    }()

    // get new connection
    conn, err := grpc.Dial(hostAddr, grpc.WithInsecure())
    if err != nil {
        return
    }
    defer conn.Close()

    // endpointName could be in two formats:
    // * endpoint_name
    // * svc_name#endpoint_name (if multiple svc)
    var svcName, endName string
    i := strings.LastIndex(endpointName, "#")
    if i > 0 {
        svcName = endpointName[:i]
        endName = endpointName[i+1:]
    } else {
        endName = endpointName
    }

    // to get accurate method path by parsing pb source
    // with svc_name and end_name
    method, err := getMethodPath(svcName, endName)
    if err != nil {
        return
    }

    // get request obj (of type proto.Message)
    req := getVarByTypeName(endName + "Request")
    if req == nil {
        return "", fmt.Errorf("Failed to get request object")
    }

    // get response obj (of type proto.Message)
    reply := getVarByTypeName(endName + "Response")
    if reply == nil {
        return "", fmt.Errorf("Failed to get response object")
    }

    if err = jsonpb.UnmarshalString(rawRequest, req); err != nil {
        return
    }

    if err = conn.Invoke(context.Background(), method, req, reply,
        grpc.EmptyCallOption{}); err != nil {
        return
    }
    return reply.String(), nil
}

func getMethodPath(svcName, endName string) (res string, err error) {
    qCandidates := _les.Query().ByKind(lesphina.KindFunction).ByName(endName).All()
    if len(qCandidates) < 1 {
        return "", fmt.Errorf("No function found by name: %s", endName)
    }

    var target *lesphina.Function
    for _, c := range qCandidates {
        if f, ok := c.(*lesphina.Function); ok {
            if len(f.Recv) < 1 {
                continue
            }

            // recv type should end with string 'Client'
            if !strings.HasSuffix(f.Recv[0].BaseType, "Client") {
                continue
            }

            if svcName != "" {
                // if svcName is given, return the first candidate under this svc
                if strings.ToLower(f.Recv[0].BaseType) == strings.ToLower(svcName) {
                    target = f
                    break
                }
            } else {
                // if svcName is not given, return the first candidate
                target = f
                break
            }
        }
    }

    if target == nil {
        return "", fmt.Errorf("Endpoint Not Found (svcName: %s, endName: %s)", svcName, endName)
    }

    rawBody := target.RawBody
    if rawBody == "" {
        return "", fmt.Errorf("Blank endpoint")
    }

    m := _regexMethodPath.FindAllStringSubmatch(rawBody, 1)
    if len(m) > 0 && len(m[0]) > 1 {
        return m[0][1], nil
    }
    return "", fmt.Errorf("No match in rawBody")
}

func recoverHandling(w http.ResponseWriter) {
    if r := recover(); r != nil {
        io.WriteString(w, r.(error).Error())
    }
}
