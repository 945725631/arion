//
// This file is generated by Arion.
//

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"io/ioutil"
	"net/http"
	"sync"
)

var (
	// endpointName : responseData (as raw json)
	respMap      = make(map[string]json.RawMessage)
	respMapGuard sync.RWMutex
)

type updateRespRequest struct {
	EndpointName string          `json:"endpointName"`
	Data         json.RawMessage `json:"data"`
}

func handleUpdateResponse(w http.ResponseWriter, req *http.Request) {
	if req.Method != "PUT" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	raw, err := ioutil.ReadAll(req.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		writeErr(w, err)
		return
	}

	reqData := &updateRespRequest{}
	if err := json.Unmarshal(raw, reqData); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		writeErr(w, err)
		return
	}

	if reqData.EndpointName == "" {
		w.WriteHeader(http.StatusBadRequest)
		writeErr(w, fmt.Errorf("Endpoint Name Should not be empty"))
		return
	}

	respMapGuard.Lock()
	respMap[reqData.EndpointName] = reqData.Data
	respMapGuard.Unlock()

	log.Printf("Set [%s] response data", reqData.EndpointName)
	w.WriteHeader(http.StatusOK)
}

func writeErr(w io.Writer, err error) {
	r := fmt.Sprintf("{error:\"%v\"}", err)
	w.Write([]byte(r))
}
